void output_partition_stat(std::ostream& response, const std::string& static_labels, const std::string& name, const std::string& type, const std::string& help, perfstat_partition_total_t partition, const std::function<double (perfstat_partition_total_t&)>& func) {
	response << "# HELP " << name << " " << help << std::endl;
	response << "# TYPE " << name << " " << type << std::endl;

	response << name << "{" << static_labels << "} " << func(partition) << std::endl;
}

void gather_partition(std::ostream& response, const std::string& static_labels) {
    std::cout << "partition metrics" << std::endl;

    perfstat_partition_total_t partition;

	if(perfstat_partition_total(NULL, &partition, sizeof(perfstat_partition_total_t), 1) <= 0) {
		perror("Error calling perfstat_partition_total");
		return;
	}

	output_partition_stat(response, static_labels, "aix_partition_online_cpus", "gauge", "number of virtual CPUs currently online on the partition", partition, [](perfstat_partition_total_t& partition) { return partition.online_cpus; });
	output_partition_stat(response, static_labels, "aix_partition_max_cpus", "gauge", "maximum number of virtual CPUs this parition can ever have", partition, [](perfstat_partition_total_t& partition) { return partition.max_cpus; });
	output_partition_stat(response, static_labels, "aix_partition_min_cpus", "gauge", "minimum number of virtual CPUs this partition must have", partition, [](perfstat_partition_total_t& partition) { return partition.min_cpus; });
	output_partition_stat(response, static_labels, "aix_partition_online_memory", "gauge", "amount of memory currently online", partition, [](perfstat_partition_total_t& partition) { return partition.online_memory; });
	output_partition_stat(response, static_labels, "aix_partition_max_memory", "gauge", "maximum amount of memory this partition can ever have", partition, [](perfstat_partition_total_t& partition) { return partition.max_memory; });
	output_partition_stat(response, static_labels, "aix_partition_min_memory", "gauge", "minimum amount of memory this partition must have", partition, [](perfstat_partition_total_t& partition) { return partition.min_memory; });
	output_partition_stat(response, static_labels, "aix_partition_entitled_proc_capacity", "gauge", "number of processor units this partition is entitled to receive", partition, [](perfstat_partition_total_t& partition) { return partition.entitled_proc_capacity; });
	output_partition_stat(response, static_labels, "aix_partition_max_proc_capacity", "gauge", "maximum number of processor units this partition can ever have", partition, [](perfstat_partition_total_t& partition) { return partition.max_proc_capacity; });
	output_partition_stat(response, static_labels, "aix_partition_min_proc_capacity", "gauge", "minimum number of processor units this partition must have", partition, [](perfstat_partition_total_t& partition) { return partition.min_proc_capacity; });
	output_partition_stat(response, static_labels, "aix_partition_proc_capacity_increment", "gauge", "increment value to the entitled capacity", partition, [](perfstat_partition_total_t& partition) { return partition.proc_capacity_increment; });
	output_partition_stat(response, static_labels, "aix_partition_unalloc_proc_capacity", "gauge", "Unallocated processor units in the shared processor pool, to which this partition belongs.", partition, [](perfstat_partition_total_t& partition) { return partition.unalloc_proc_capacity; });
	output_partition_stat(response, static_labels, "aix_partition_var_proc_capacity_weight", "gauge", "Unallocated variable capacity, weight units in shared processor pool, to which this partition belongs.", partition, [](perfstat_partition_total_t& partition) { return partition.var_proc_capacity_weight; });
	output_partition_stat(response, static_labels, "aix_partition_unalloc_var_proc_capacity_weight", "gauge", "of variable processor capacity weight units currently unallocated  in the shared processor pool this partition belongs to", partition, [](perfstat_partition_total_t& partition) { return partition.unalloc_var_proc_capacity_weight; });
	output_partition_stat(response, static_labels, "aix_partition_online_phys_cpus_sys", "gauge", "number of physical CPUs currently active in the system containing this partition", partition, [](perfstat_partition_total_t& partition) { return partition.online_phys_cpus_sys; });
	output_partition_stat(response, static_labels, "aix_partition_max_phys_cpus_sys", "gauge", "maximum possible number of physical CPUs in the system containing this partition", partition, [](perfstat_partition_total_t& partition) { return partition.max_phys_cpus_sys; });
	output_partition_stat(response, static_labels, "aix_partition_phys_cpus_pool", "gauge", "Available physical CPUs in the shared processor pool, to which this partition belongs.", partition, [](perfstat_partition_total_t& partition) { return partition.phys_cpus_pool; });
	output_partition_stat(response, static_labels, "aix_partition_puser", "counter", "raw number of physical processor tics in user mode", partition, [](perfstat_partition_total_t& partition) { return partition.puser; });
	output_partition_stat(response, static_labels, "aix_partition_psys", "counter", "raw number of physical processor tics in system mode", partition, [](perfstat_partition_total_t& partition) { return partition.psys; });
	output_partition_stat(response, static_labels, "aix_partition_pidle", "counter", "raw number of physical processor tics idle", partition, [](perfstat_partition_total_t& partition) { return partition.pidle; });
	output_partition_stat(response, static_labels, "aix_partition_pwait", "counter", "raw number of physical processor tics waiting for I/O", partition, [](perfstat_partition_total_t& partition) { return partition.pwait; });
	output_partition_stat(response, static_labels, "aix_partition_pool_idle_time", "counter", "number of clock tics a processor in the shared pool was idle", partition, [](perfstat_partition_total_t& partition) { return partition.pool_idle_time; });
	output_partition_stat(response, static_labels, "aix_partition_phantintrs", "counter", "number of phantom interrupts received by the partition", partition, [](perfstat_partition_total_t& partition) { return partition.phantintrs; });
	output_partition_stat(response, static_labels, "aix_partition_invol_virt_cswitch", "counter", "number involuntary virtual CPU context switches", partition, [](perfstat_partition_total_t& partition) { return partition.invol_virt_cswitch; });
	output_partition_stat(response, static_labels, "aix_partition_vol_virt_cswitch", "counter", "number voluntary virtual CPU context switches", partition, [](perfstat_partition_total_t& partition) { return partition.vol_virt_cswitch; });
	output_partition_stat(response, static_labels, "aix_partition_timebase_last", "counter", "Total number of clock ticks", partition, [](perfstat_partition_total_t& partition) { return partition.timebase_last; });
	output_partition_stat(response, static_labels, "aix_partition_reserved_pages", "gauge", "Currenlty number of 16GB pages. Cannot participate in DR operations", partition, [](perfstat_partition_total_t& partition) { return partition.reserved_pages; });
	output_partition_stat(response, static_labels, "aix_partition_reserved_pagesize", "gauge", "Currently 16GB pagesize Cannot participate in DR operations", partition, [](perfstat_partition_total_t& partition) { return partition.reserved_pagesize; });
	output_partition_stat(response, static_labels, "aix_partition_idle_donated_purr", "counter", "number of idle cycles donated by a dedicated partition enabled for donation", partition, [](perfstat_partition_total_t& partition) { return partition.idle_donated_purr; });
	output_partition_stat(response, static_labels, "aix_partition_idle_donated_spurr", "counter", "number of idle spurr cycles donated by a dedicated partition enabled for donation", partition, [](perfstat_partition_total_t& partition) { return partition.idle_donated_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_busy_donated_purr", "counter", "number of busy cycles donated by a dedicated partition enabled for donation", partition, [](perfstat_partition_total_t& partition) { return partition.busy_donated_purr; });
	output_partition_stat(response, static_labels, "aix_partition_busy_donated_spurr", "counter", "number of busy spurr cycles donated by a dedicated partition enabled for donation", partition, [](perfstat_partition_total_t& partition) { return partition.busy_donated_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_idle_stolen_purr", "counter", "number of idle cycles stolen by the hypervisor from a dedicated partition", partition, [](perfstat_partition_total_t& partition) { return partition.idle_stolen_purr; });
	output_partition_stat(response, static_labels, "aix_partition_idle_stolen_spurr", "counter", "number of idle spurr cycles stolen by the hypervisor from a dedicated partition", partition, [](perfstat_partition_total_t& partition) { return partition.idle_stolen_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_busy_stolen_purr", "counter", "number of busy cycles stolen by the hypervisor from a dedicated partition", partition, [](perfstat_partition_total_t& partition) { return partition.busy_stolen_purr; });
	output_partition_stat(response, static_labels, "aix_partition_busy_stolen_spurr", "counter", "number of busy spurr cycles stolen by the hypervisor from a dedicated partition", partition, [](perfstat_partition_total_t& partition) { return partition.busy_stolen_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_shcpus_in_sys", "gauge", "Number of physical processors allocated for Shared Processor use, across all shared processors pool (i.e Pool ID=0).", partition, [](perfstat_partition_total_t& partition) { return partition.shcpus_in_sys; });
	output_partition_stat(response, static_labels, "aix_partition_max_pool_capacity", "gauge", "Maximum processor capacity of shared processor pool, to which this partition belongs.", partition, [](perfstat_partition_total_t& partition) { return partition.max_pool_capacity; });
	output_partition_stat(response, static_labels, "aix_partition_entitled_pool_capacity", "gauge", "Entitled processor capacity of shared processor pool, to which this partition belongs.", partition, [](perfstat_partition_total_t& partition) { return partition.entitled_pool_capacity; });
	output_partition_stat(response, static_labels, "aix_partition_pool_max_time", "counter", "Summation of maximum time(in nano seconds) that could be consumed by the Shared processor pool, to which this parttion belongs", partition, [](perfstat_partition_total_t& partition) { return partition.pool_max_time; });
	output_partition_stat(response, static_labels, "aix_partition_pool_busy_time", "counter", "Summation of busy (non-idle) time (in nano seconds) accumulated across all partitions in the Shared processor pool, to which this partition belongs.", partition, [](perfstat_partition_total_t& partition) { return partition.pool_busy_time; });
	output_partition_stat(response, static_labels, "aix_partition_pool_scaled_busy_time", "counter", "Summation of busy (non-idle) time (in nano seconds) accumulated across all partitions in the Shared Processor  pool, to which this partition belongs. The time is against rated/nominal frequency", partition, [](perfstat_partition_total_t& partition) { return partition.pool_scaled_busy_time; });
	output_partition_stat(response, static_labels, "aix_partition_shcpu_tot_time", "counter", "Summation of total time (in nano seconds) across all physical processors allocated for shared processor (i.e Pool ID=0) use, across all share processor pools", partition, [](perfstat_partition_total_t& partition) { return partition.shcpu_tot_time; });
	output_partition_stat(response, static_labels, "aix_partition_shcpu_busy_time", "counter", "Summation of busy (non-idle) time (in nano seconds) accumulated across all physical processors allocated for shared processor (i.e pool ID=0)use, across all share processor pools.", partition, [](perfstat_partition_total_t& partition) { return partition.shcpu_busy_time; });
	output_partition_stat(response, static_labels, "aix_partition_shcpu_scaled_busy_time", "counter", "Summation of busy (non-idle) time (in nano seconds) accumulated across all physical processors for shared processor (i.e Pool ID=0)use, across all share processor pools. The time is against rated/nominal frequency.", partition, [](perfstat_partition_total_t& partition) { return partition.shcpu_scaled_busy_time; });
	output_partition_stat(response, static_labels, "aix_partition_var_mem_weight", "gauge", "variable memory capacity weight", partition, [](perfstat_partition_total_t& partition) { return partition.var_mem_weight; });
	output_partition_stat(response, static_labels, "aix_partition_iome", "gauge", "I/O memory entitlement of the partition in bytes", partition, [](perfstat_partition_total_t& partition) { return partition.iome; });
	output_partition_stat(response, static_labels, "aix_partition_pmem", "gauge", "Physical memory currently backing the partition's logical memory in bytes", partition, [](perfstat_partition_total_t& partition) { return partition.pmem; });
	output_partition_stat(response, static_labels, "aix_partition_hpi", "counter", "number of hypervisor page-ins", partition, [](perfstat_partition_total_t& partition) { return partition.hpi; });
	output_partition_stat(response, static_labels, "aix_partition_hpit", "counter", "Time spent in hypervisor page-ins (in nanoseconds)", partition, [](perfstat_partition_total_t& partition) { return partition.hpit; });
	output_partition_stat(response, static_labels, "aix_partition_hypv_pagesize", "gauge", "Hypervisor page size in KB", partition, [](perfstat_partition_total_t& partition) { return partition.hypv_pagesize; });
	output_partition_stat(response, static_labels, "aix_partition_online_lcpus", "gauge", "Number of online logical cpus", partition, [](perfstat_partition_total_t& partition) { return partition.online_lcpus; });
	output_partition_stat(response, static_labels, "aix_partition_smt_thrds", "gauge", "Number of SMT threads", partition, [](perfstat_partition_total_t& partition) { return partition.smt_thrds; });
	output_partition_stat(response, static_labels, "aix_partition_puser_spurr", "counter", "number of spurr cycles spent in user mode", partition, [](perfstat_partition_total_t& partition) { return partition.puser_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_psys_spurr", "counter", "number of spurr cycles spent in kernel mode", partition, [](perfstat_partition_total_t& partition) { return partition.psys_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_pidle_spurr", "counter", "number of spurr cycles spent in idle mode", partition, [](perfstat_partition_total_t& partition) { return partition.pidle_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_pwait_spurr", "counter", "number of spurr cycles spent in wait mode", partition, [](perfstat_partition_total_t& partition) { return partition.pwait_spurr; });
	output_partition_stat(response, static_labels, "aix_partition_spurrflag", "gauge", "set if running in spurr mode", partition, [](perfstat_partition_total_t& partition) { return partition.spurrflag; });
	output_partition_stat(response, static_labels, "aix_partition_power_save_mode", "gauge", "Power save mode for the LPAR. Introduced through LI 53K PRF : Feature 728292", partition, [](perfstat_partition_total_t& partition) { return partition.power_save_mode; });
	output_partition_stat(response, static_labels, "aix_partition_true_memory", "gauge", "True Memory Size in 4KB pages", partition, [](perfstat_partition_total_t& partition) { return partition.true_memory; });
	output_partition_stat(response, static_labels, "aix_partition_expanded_memory", "gauge", "Expanded Memory Size in 4KB pages", partition, [](perfstat_partition_total_t& partition) { return partition.expanded_memory; });
	output_partition_stat(response, static_labels, "aix_partition_target_memexp_factr", "gauge", "Target Memory Expansion Factor scaled by 100", partition, [](perfstat_partition_total_t& partition) { return partition.target_memexp_factr; });
	output_partition_stat(response, static_labels, "aix_partition_current_memexp_factr", "gauge", "Current Memory Expansion Factor scaled by 100", partition, [](perfstat_partition_total_t& partition) { return partition.current_memexp_factr; });
	output_partition_stat(response, static_labels, "aix_partition_target_cpool_size", "gauge", "Target Compressed Pool Size in bytes", partition, [](perfstat_partition_total_t& partition) { return partition.target_cpool_size; });
	output_partition_stat(response, static_labels, "aix_partition_max_cpool_size", "gauge", "Max Size of Compressed Pool in bytes", partition, [](perfstat_partition_total_t& partition) { return partition.max_cpool_size; });
	output_partition_stat(response, static_labels, "aix_partition_min_ucpool_size", "gauge", "Min Size of Uncompressed Pool in bytes", partition, [](perfstat_partition_total_t& partition) { return partition.min_ucpool_size; });
	output_partition_stat(response, static_labels, "aix_partition_ame_deficit_size", "gauge", "Deficit memory size in bytes", partition, [](perfstat_partition_total_t& partition) { return partition.ame_deficit_size; });
	output_partition_stat(response, static_labels, "aix_partition_cmcs_total_time", "counter", "Total CPU time spent due to active memory expansion", partition, [](perfstat_partition_total_t& partition) { return partition.cmcs_total_time; });
	output_partition_stat(response, static_labels, "aix_partition_purr_coalescing", "counter", "If the calling partition is authorized to see pool wide statistics then PURR cycles consumed to coalesce data else set to zero.", partition, [](perfstat_partition_total_t& partition) { return partition.purr_coalescing; });
	output_partition_stat(response, static_labels, "aix_partition_spurr_coalescing", "counter", "If the calling partition is authorized to see pool wide statistics then SPURR cycles consumed to coalesce data else set to zero.", partition, [](perfstat_partition_total_t& partition) { return partition.spurr_coalescing; });
	output_partition_stat(response, static_labels, "aix_partition_MemPoolSize", "gauge", "Indicates the memory pool size of the pool that the partition belongs to (in bytes)., mpsz", partition, [](perfstat_partition_total_t& partition) { return partition.MemPoolSize; });
	output_partition_stat(response, static_labels, "aix_partition_IOMemEntInUse", "gauge", "I/O memory entitlement of the LPAR in use in bytes. iomu", partition, [](perfstat_partition_total_t& partition) { return partition.IOMemEntInUse; });
	output_partition_stat(response, static_labels, "aix_partition_IOMemEntFree", "gauge", "free I/O memory entitlement in bytes.  iomf", partition, [](perfstat_partition_total_t& partition) { return partition.IOMemEntFree; });
	output_partition_stat(response, static_labels, "aix_partition_IOHighWaterMark", "gauge", "high water mark of I/O memory entitlement usage in bytes. iohwn", partition, [](perfstat_partition_total_t& partition) { return partition.IOHighWaterMark; });
	output_partition_stat(response, static_labels, "aix_partition_purr_counter", "counter", "number of purr cycles spent in user + kernel mode", partition, [](perfstat_partition_total_t& partition) { return partition.purr_counter; });
	output_partition_stat(response, static_labels, "aix_partition_spurr_counter", "counter", "number of spurr cycles spent in user + kernel mode", partition, [](perfstat_partition_total_t& partition) { return partition.spurr_counter; });
	output_partition_stat(response, static_labels, "aix_partition_real_free", "gauge", "free real memory (in 4KB pages)", partition, [](perfstat_partition_total_t& partition) { return partition.real_free; });
	output_partition_stat(response, static_labels, "aix_partition_real_avail", "gauge", "number of pages available for user application (memfree + numperm - minperm - minfree )", partition, [](perfstat_partition_total_t& partition) { return partition.real_avail; });
}
